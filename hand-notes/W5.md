# CS2103 Notes (Week 5)

# W4 Lecture 6/9
## Lecture summary

1. Ask
    - Don't assume, clarify
    - Surveys
    - Interviews
    - Focus groups
    - Ask users, customers, investors, developers, government, stakeholders
2. Invent yourself
    - Study existing products 
    - Observe users
    - Brainstorming
3. Record and specifying techniques
    - Prose (just write it down)
    - User stories
        1. Role (_as a product owner_)
        2. Goal/function (_I want to..._)
        3. Benefit (_so that other users can see..._)
    - Feature list
    - Use cases
        - How user interacts with the system
4. Prototypes
    - Low-fidelity
    - High-fidelity
    - Functional
5. Supplementary requirements
    - Mostly non-functional requirements

## Resume
* Education
    - If CAP is not high
    - Mention good grades for _relevant_ modules
    - Do tutorships
* Projects
    - _ProjectName_: _description_ (school project)
    - Side-project
    - Contribute to OSS projects (actual production code)
* Competencies
    - Can be tweaked to match the job
    - E.g.

    3 projects, 10 KLoC in total
    used JavaFX, TestFX, Gradle, Travis
    notable PRs: PR1, PRR2

# Requirements

* _Software requirement_
    - Specifies need to be fulfilled by software product
    - Need to be gathered, analysed, specified, managed
* Software project
    - _Brown-field_: develop product to replace/update an existing software product
    - _Green-field_: develop totally new system with no precedent
* Come from stakeholders
    - Parties that are potentially affected by the software project
    - E.g. users, customers, investors, developers, government, stakeholders 
* Identifying requirements
    - Often not easy
    - E.g. Stakeholders not aware of their precise needs
    - E.g. Not know how to communicate requirements correctly
    - E.g. Not willing to spend effort in identifying requirement
* Quality of requirements
    - Well-defined
    - Unambiguous
    - Testable (verifiable)
    - Clear (concise, terse, simple, precise)
    - Correct
    - Understandable
    - Feasible (realistic, possible)
    - Independent
    - Atomic (not divisble any further)
    - Necessary
    - Implementation-free
    - Set of requirements should be
        - Consistent
        - Non-redundant
        - Complete
* Prioritising requirements
    - Based on importance and urgency
    - Keep in mind constraints, schedule, budget, resources, goals etc
    - Group requirements into priority categories
        - Subjective
        - Defined by stakeholders
        - E.g. `Essential`, `Typical`, `Novel`
        - E.g. `High`, `Medium`, `Low`
        - E.g. `Level 0`, `Level 1` etc
    - Can discard requirements if out-of-scope

1. **Functional requirements**
    - Specify what the system should do
    
2. **Non-functional requirements**
    - Specify the constraints under which system is developed and operated
    - Constraints
        - E.g. Need to be backward compatible with earlier versions
    - Data requirements
        - E.g. Size, volatility - how often data change, persistency - saving data permanently
    - Environment requirements
        - E.g. Compatibility with technical environmens
    - Performance requirements
        - E.g. System should respond within 2 seconds
    - Quality requirements
        - E.g. Novice should be able to use
    - E.g. Accessibility, Capacity, Compliance with regulations, Documentation, Disaster recovery, Efficiency, Extensibility, Fault tolerance, Interoperability, Maintainability, Privacy, Portability, Quality, Reliability, Response time, Robustness, Scalability, Security, Stability, Testability etc.
    - Better to know earlier
        - Easier to miss (stakeholders tend to think of functional requirements first)
        - Sometimes critical to success of software

# Requirement Techniques: **Gathering**

1. Brainstorming
    - Group activity to generate a large number of diverse and creative ideas for solution of problem
    - No "bad" ideas
    - Aim is to _generate_ ideas, not validate them
    - Think outside the box and put crazy ideas on table
2. Product surveys
    - Study existing products
    - Address shortcomings of existing solutions with new product
    - Use product manuals and other forms of documentation of existing system
    - Look at features and interactions of current products
3. Observation
    - Observe users in natural work environment
    - Uncover product requirements
    - Usage data of existing system, information on how it is being used
    - Find situations which current system makes it difficult for user
4. User surveys
    - Surveys to _solicit responses and opinions_ from large number of stakeholders
    - On current product, on new product
5. Interviews
    - Interview stakeholders and domain experts (expert of domain which product is connected to)
    - Gather useful information that project requires
6. Focus groups
    - A kind of informal interview within interactive group setting
    - Ask group of people about their understanding of a specific issue, process, product, advertisement etc
7. Prototyping
    - Mock up, scaled down version, partial system constructed
    - Get users' (quick) feedback
    - Validate technical concept ("proof-of-concept" prototype)
    - Give preview of what is to come, or to compare multiple alternatives on a small scale before committing fully to one alternative
    - Early field-testing under controlled conditions
    - Can be used to undercover requirements, particularly those related to _how users interact_ with system
    - E.g. wireframe diagram
    - Can serve as specification on what to build as well

# Requirement Techniques: **Specifying**

1. Prose
    * Textual description used to describe requirements
    * Useful when describing abstract ideas
        - E.g. vision of product
    * Avoid using lengthy prose, can be hard to follow
2. Feature lists
    * List of features of a product grouped according to some criteria
        - E.g. aspect, priority, order of delivery etc
    * Example:
<!-- -->
    // Minesweeper
    1. Basic play – Single player play.
    2. Difficulty levels
        - Medium-levels
        - Advanced levels
    3. Versus play – Two players can play against each other.
    4. Timer – Additional fixed time restriction on the player.
    5. ...

3. User stories
    * Short, simple descriptions of a feature told from **perspective** of the person who desires new capability, usually **user/customer** of system
    * Written in a natural language (not formal)
    * Do not contain enough details to form a complete system specification
    * Common format: `As a {user type/role} I can {function} so that {benefit}`
        - _user_, _function_, _benefit_
        - Can omit `{benefit}` if obvious
        - Recommended to confirm there is a concrete benefit even if omit if from user story (or else end up doing features that have no real benefit)
        - Can add more characteristics to `{user role}` to provide more context to user story
    - Can write stories on _various levels_
        - High-level user stories/epics/themes: cover bigger functionality
        - Break these down to multiple stories of normal size
    - Can add _conditions of satisfaction_ to user story
        - Specify things that need to be true for story to be accepted as 'done'
    - Other useful info that can be added
        - E.g. Priority: how important story is
        - E.g. Size: estimated effort to implement story
        - E.g. Urgency: how soon feature is needed
    * How:
        - Write on index cards/sticky notes
        - Arrange on walls/tables (facilitate planning, discussion)
        - Or use software (to manage digitally) which is better for longer-term management and if team not co-located
            - E.g. GitHub Project Boards, Google Sheets, Trello
    * Capture user requirements in a way that isconvenient for
        - Scoping (which features to include in product)
        - Estimation (how much effort each feature willtake)
        - Scheduling (when to deliver each feature)
    * Differ from traditional requirements specification (i.e. prose) in level of detail
        - Should only provide enough details to make reasonably low risk estimate of how long it will take to implement user story
        - Work out more detailed description of requirements when meeting customers face-to-face
    * Can capture non-functional requirements
    * Handy for recording requirements during early stages of requirements gathering
    * **Tips**:
        - Define _target user_ (profile and work patternss)
        - Define _problem scope_ (exact problem to solve)
        - Don't be too hasty to discard 'unusual' user stories (can make the product unique)
        - Don't go into too much details
        - Don't be biased by pre-conceived product ideas
        - Don't discuss implementation details or whether you are actually going to implement it
    * Examples:
<!-- -->
    // Learning Management System
    - As a student, I can download files uploaded by lecturers, so    that I can get my own copy of the files
    - As a lecturer, I can create discussion forums, so that  students can discuss things online
    - As a tutor, I can print attendance sheets, so that I can take   attendance during the clas

    // More characteristics to user role
    - As a **forgetful** user, I can view a password hint, so that I can recall my password.
    - As an **expert** user, I can tweak the underlying formatting tags of the document, so that I can format the document exactly as I need
    
    // Example of an epic
    [Epic] As a lecturer, I can monitor student participation levels

    - As a lecturer, I can view the forum post count of each student
    so that I can identify the activity level of students in the    forum
    - As a lecturer, I can view webcast view records of each student
    so that I can identify the students who did not view webcasts
    - As a lecturer, I can view file download statistics of each  student
    so that I can identify the students who do not download     lecture materials

    // Example of a user story with conditions of satisfaction
    As a lecturer, I can view the forum post count of each student so that I can identify the activity level of students in the forum.

    Conditions:

    [v] Separate post count for each forum should be shown
    [] Total post count of a student should be shown
    [v] The list should be sortable by student name and post count

4. Glossary
    * Ensures that all stakeholders have a **common understanding** of noteworthy terms, abbreviations, acronyms etc.
5. Supplementary Requirements
    * A section used to capture requirements that do not fit elsewhere
    * Typically where non-functional requirements listed

# Code Quality

* Learn to follow a standard (objective)
* Comments
    - If you must
    - wrong, tests don't check code, may not be updated
    - good code that are self-explanatory don't really need comments that explain the code 
    - Need comments to explain what the code does, at a higher level
* Avoid magic literals
    - E.g.`SUBSIDY` instead of `250`
* Exploit abstraction
    -SLAP (single level of abstraction per function)
        - Same level of abstraction within a method
    - Use guard conditions
        Reduce nesting of happy path (i.e. main method) of code
* Optimise, if you must
* Messy things get messier
    - Clean up code **frequently**
    - Refactoring
        - Improve program's internal structure
        - In _small_ steps
        - _Without_ modifying its external behaviour

## 1. **Readability**
## 2. **Naming**
## 3. **Unsafe practices**
## 4. **Code comments**

# Refactoring

# Assertions (Java `assert`)

* Used to define assumptions about program state so that runtime can verify them
* Example: _When the execution comes to this point, the variable **v** cannot be null_
* Assertion failure
    - Indicate possible bug in code
    - Code result in program state violates assumption about how code _should_ behave
* When runtime detects an assertion failure
    - Take some drastic action
    - E.g. terminate execution with error message
    - The sooner the execution stops, the safer it is
* Code implementation: 
    - keyword `assert`
<!-- -->
    x = getX();
    // If x is not 0 at this point, assertion will fail with given message
    assert x == 0 : "x should be 0";
    ...

* Can disable assertions without modifying code (default)
<!-- -->
    // Method 1 (run assertions)
    java -enableassertions HelloWorld
    // Method 2
    java -ea HelloWorld
    // Run without verifying assertions (default)
    java -disableassertions HelloWorld

* Enable assertions in Intellij, confirm assertions are being verified
    - Insert `assert false`
* Difference with JUnit assertions
    - Java `assert` similar in purpose
    - But JUnit assertions more powerful, customised for testing
    - Junit assertions not disable by default
    - Where to use
        - JUnit assertions: in test code
        - Java `assert`: in functional code
* Use liberally in code
    - Low impact on performance
    - Worth the additional safety they provide
* Do **not** use assertions to do _work_
    - Because assertions can be disabled
    - Program will stop working when assertions are not enabled
    - If method is performing some work necessary for program, program will not work correctly when assertions disabled
    - Example:
<!-- -->
    ...
    assert writeFile() : "File writing is supposed to return true

* Suitable for verifying assumptions about
    - Internal Invariants
    - Control-Flow Invariants
    - Preconditions
    - Postconditions
    - Class Invariants
* Complementary with exceptions in handling errors in software
    - But serve different purposes
    - Both should be used in code
    - Raising an exception
        - Indicates an unusual condition created by user or environment
        - Exceptions should **not** **terminate** program
        - E.g. user inputs an unacceptable input
        - E.g. file needed for program is missing
    - Assertion failure
        - Indicates programmer made a mistake in code
        - E.g. Null value returned from method that is not supposed to return null under any circumstances

# Java: **_lambdas_** and **_streams_**

* Java 8 new features
* [Link](https://winterbe.com/posts/2014/03/16/java-8-tutorial/)

## _**lambdas**_

* Adds functional processing capability to Java
* Syntax: `parameter -> expression body`
* Optional in syntax
    - Type declaration
        - No need to declare type of a param
        - Compiler can inference the same from value of param
    - Parenthesis around parameter
        - No need to declare a single param in parenthesis
        - Although required for multiple params
    - Curly braces
        - No need to use in expression body if body contains single statement
    - Return keyword
        - Compiler automatically returns value if body has single expression to return value
        - Need curly braces to indicate that expression returns a value
* Primarily used to define inline implementation of a functional interface (i.e. interface with a single method)
* Eliminates the need of anonymous class
* Lambda expression throws a compilation error, if variable assigned a value the second time
* Example 1:
<!-- -->

    import java.util.Collections;
    import java.util.List;
    import java.util.ArrayList;
    import java.util.Comparator;

    public class Java8Tester {

    public static void main(String args[]) {
    
        List<String> names1 = new ArrayList<String>();
        names1.add("Mahesh ");
        names1.add("Suresh ");
        names1.add("Ramesh ");
        names1.add("Naresh ");
        names1.add("Kalpesh ");
            
        List<String> names2 = new ArrayList<String>();
        names2.add("Mahesh ");
        // ...
            
        Java8Tester tester = new Java8Tester();
        System.out.println("Sort using Java 7 syntax: ");
            
        tester.sortUsingJava7(names1);
        System.out.println(names1);
        System.out.println("Sort using Java 8 syntax: ");
            
        tester.sortUsingJava8(names2);
        System.out.println(names2);
    }
    
    //sort using java 7
    private void sortUsingJava7(List<String> names) {   
        Collections.sort(names, new Comparator<String>() {
            @Override
            public int compare(String s1, String s2) {
                return s1.compareTo(s2);
            }
        });
    }
    
    //sort using java 8
    private void sortUsingJava8(List<String> names) {
        Collections.sort(names, (s1, s2) -> s1.compareTo(s2));
    }
    }

    // Output using Java 7, 8 syntax
    // [ Kalpesh Mahesh Naresh Ramesh Suresh ]

* Example 2:
<!-- -->
    //with type declaration
    MathOperation addition = (int a, int b) -> a + b;
    System.out.println("10 + 5 = " + tester.operate(10, 5, addition)) ;	
    
    //with out type declaration
    MathOperation subtraction = (a, b) -> a - b;	
    
    //with return statement along with curly braces
    MathOperation multiplication = (int a, int b) -> return a * b;  };	
    
    //without return statement and without curly braces
    MathOperation division = (int a, int b) -> a / b;

    //without parenthesis
    GreetingService greetService1 = message ->
    System.out.println("Hello " + message); 	
    greetService1.sayMessage("Mahesh");
    
    //with parenthesis
    GreetingService greetService2 = (message) ->
    System.out.println("Hello " + message);

* Example 3:
<!-- -->
    // Can read final local variables from outer scope of lambda expression
    final int num = 1;
    // OR, no need to declare final
    int num = 1
    Converter<Integer, String> stringConverter =
            (from) -> String.valueOf(from + num);

    stringConverter.convert(2);

* Example 4:
<!-- -->
    // this does not compile (num must be implicitly final)
    // cannot write to num from within lambda expression also
    int num = 1;
    Converter<Integer, String> stringConverter =
            (from) -> String.valueOf(from + num);
    num = 3;

## _**streams**_

* Stream API `java.util.Stream`
* Facilitate pipeline processing
* Represents a sequence of elements where one or more operations can be performed
    - _sequence of elements_: a set of elements of a specific type in a sequential manner
    - A stream gets them on demand, never stores them
* Stream operations either _intermediate_ or _terminal_
    - _intermediate_: return stream itself such that multiple method calls can be chained in a row
    - _terminal_: return a result of a certain type
* Streams created on input sources (e.g. `java.util.Collection` like lists, sets, **not** maps)
* Stream operations can be executed sequentially or in parallel

### **1. `stream()`**

* Returns a sequential stream considering collection as its source
* Example (**_filter_**):
    - Filter accept a predicate to filter all elements of stream
    - This operation is _immediate_
    - Another stream operation _forEach_
    - It accepts a consumer to be executed for each element in filtered stream
    - It is a terminal operation and is _void_, so cannot call another stream operation
<!-- -->
    stringCollection
        .stream()
        .filter((s) -> s.startsWith("a"))
        .forEach(System.out::println);

    // "aaa2", "aaa1"

* Example (**_sorted_**):
    - `sorted` is _intermediate_ operation, returns sorted **view** of stream
    - Ordering of backed collection is not manipulated, `stringCollection` ordering is still same
    - Elements sorted in natural order unless pass in a custom `Comparator`
<!-- -->
    stringCollection
        .stream()
        // 
        .sorted()
        .filter((s) -> s.startsWith("a"))
        .forEach(System.out::println);

    // "aaa1", "aaa2"

* Example (**_map_**):
    - `map` is an intermediate operation, converts each element into another object via given function (can also transform each object into another type)
<!-- -->
    stringCollection
        .stream()
        .map(String::toUpperCase)
        .sorted((a, b) -> b.compareTo(a))
        .forEach(System.out::println);

    // "DDD2", "DDD1", "CCC", "BBB3", "BBB2", "AAA2", "AAA1"

* Example (**_map_**):
    - Check if a certain predicate matches the stream
    - All matching operation are _terminal_, return boolean result
<!-- -->
    boolean anyStartsWithA =
        stringCollection
            .stream()
            .anyMatch((s) -> s.startsWith("a"));

    System.out.println(anyStartsWithA);      // true

    boolean allStartsWithA =
        stringCollection
            .stream()
            .allMatch((s) -> s.startsWith("a"));

    System.out.println(allStartsWithA);      // false

    boolean noneStartsWithZ =
        stringCollection
            .stream()
            .noneMatch((s) -> s.startsWith("z"));

    System.out.println(noneStartsWithZ);      // true

* Example (**_count_**):
    - `count` is a terminal operation, returns the number of elements in the stream as a `long`
<!-- -->
    long startsWithB =
        stringCollection
            .stream()
            .filter((s) -> s.startsWith("b"))
            .count();

    System.out.println(startsWithB);    // 3

* Example (**_reduce_**):
    - `reduce` is a terminal operation that performs a reduction on elements of the stream with given function
    - Returns an `Optional` holding the reduced value
<!-- -->
    Optional<String> reduced =
        stringCollection
            .stream()
            .sorted()
            .reduce((s1, s2) -> s1 + "#" + s2);

    reduced.ifPresent(System.out::println);
    // "aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2"

### **2. `parallelStream()`** 

* Returns a parallel Stream considering collection as its source
* Operations on parallel streams performed concurrent on multiple threads
* Increases performance, especially for a large list
* Notation: `.parallelStream()`
* Example:
<!-- -->
    long count = values.parallelStream().sorted().count();

# Continuous Integration/Deployment

* Integration: combining parts of a software product to form a whole
* Continuous integration (CI): extreme application of build automation
    - After each code change, integration, building, testing happens automatically
* Continuous Deployment (CD): natural extension of CI
    - Changes integrated continuously, and also deployed to end-users at the same time
* Examples of CI/CD tools
    - Travis, Jenkins, Appveyor CircleCIs

## Build Automation

* Build automation tools
    - Automate steps of build process
    - Usually by build scripts
* Example of complex multi-step process of building a product from source code
    - Pull code from revision control system
    - Compile
    - Link
    - Run automated tests
    - Automatically update release documents (e.g. build number)
    - Package into a distributable
    - Push to repo
    - Deploy to a server
    - Delete temporary files created during building/testing
    - Email developers of new build
    - Etc.
* Can be scheduled (e.g. every day at midnight)
* Can be triggered by various events (e.g. triggered by a code push to revision control system)
* Popular build tools
    - Gradle, Maven, Aphache Ant, GNU Make (Java)
    - Grunt (JavaScript
    - Rake (Ruby))
* Build tools can also serve as _dependency management tools_
    - Depend on constantly evolving third party libraries
    - Need to download correct version of required libraries, update regularly
    - E.g. Maven, Gradle

# Other: Java aggregate operations

    // TODO

| Operation | Description | Example |
| --- | --- | --- |
| `filter` | | |
| `map` | | |
| `limit` | | |
| `reduce` | | |
| `find` | | |
| `match` | | |



