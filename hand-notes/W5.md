# CS2103 Notes (Week 5)

## Quotes

Edsger Dijkstra:

The competent programmer is fully aware of the strictly limited size of his own skull; therefore he approaches the programming task in full humility, and among other things he **avoids clever tricks like the plague**.



# W4 Lecture 6/9
## Lecture summary

1. Ask
    - Don't assume, clarify
    - Surveys
    - Interviews
    - Focus groups
    - Ask users, customers, investors, developers, government, stakeholders
2. Invent yourself
    - Study existing products 
    - Observe users
    - Brainstorming
3. Record and specifying techniques
    - Prose (just write it down)
    - User stories
        1. Role (_as a product owner_)
        2. Goal/function (_I want to..._)
        3. Benefit (_so that other users can see..._)
    - Feature list
    - Use cases
        - How user interacts with the system
4. Prototypes
    - Low-fidelity
    - High-fidelity
    - Functional
5. Supplementary requirements
    - Mostly non-functional requirements

## Resume
* Education
    - If CAP is not high
    - Mention good grades for _relevant_ modules
    - Do tutorships
* Projects
    - _ProjectName_: _description_ (school project)
    - Side-project
    - Contribute to OSS projects (actual production code)
* Competencies
    - Can be tweaked to match the job
    - E.g.

    3 projects, 10 KLoC in total
    used JavaFX, TestFX, Gradle, Travis
    notable PRs: PR1, PRR2

# Requirements

* _Software requirement_
    - Specifies need to be fulfilled by software product
    - Need to be gathered, analysed, specified, managed
* Software project
    - _Brown-field_: develop product to replace/update an existing software product
    - _Green-field_: develop totally new system with no precedent
* Come from stakeholders
    - Parties that are potentially affected by the software project
    - E.g. users, customers, investors, developers, government, stakeholders 
* Identifying requirements
    - Often not easy
    - E.g. Stakeholders not aware of their precise needs
    - E.g. Not know how to communicate requirements correctly
    - E.g. Not willing to spend effort in identifying requirement
* Quality of requirements
    - Well-defined
    - Unambiguous
    - Testable (verifiable)
    - Clear (concise, terse, simple, precise)
    - Correct
    - Understandable
    - Feasible (realistic, possible)
    - Independent
    - Atomic (not divisble any further)
    - Necessary
    - Implementation-free
    - Set of requirements should be
        - Consistent
        - Non-redundant
        - Complete
* Prioritising requirements
    - Based on importance and urgency
    - Keep in mind constraints, schedule, budget, resources, goals etc
    - Group requirements into priority categories
        - Subjective
        - Defined by stakeholders
        - E.g. `Essential`, `Typical`, `Novel`
        - E.g. `High`, `Medium`, `Low`
        - E.g. `Level 0`, `Level 1` etc
    - Can discard requirements if out-of-scope

1. **Functional requirements**
    - Specify what the system should do
    
2. **Non-functional requirements**
    - Specify the constraints under which system is developed and operated
    - Constraints
        - E.g. Need to be backward compatible with earlier versions
    - Data requirements
        - E.g. Size, volatility - how often data change, persistency - saving data permanently
    - Environment requirements
        - E.g. Compatibility with technical environmens
    - Performance requirements
        - E.g. System should respond within 2 seconds
    - Quality requirements
        - E.g. Novice should be able to use
    - E.g. Accessibility, Capacity, Compliance with regulations, Documentation, Disaster recovery, Efficiency, Extensibility, Fault tolerance, Interoperability, Maintainability, Privacy, Portability, Quality, Reliability, Response time, Robustness, Scalability, Security, Stability, Testability etc.
    - Better to know earlier
        - Easier to miss (stakeholders tend to think of functional requirements first)
        - Sometimes critical to success of software

# Requirement Techniques: **Gathering**

1. Brainstorming
    - Group activity to generate a large number of diverse and creative ideas for solution of problem
    - No "bad" ideas
    - Aim is to _generate_ ideas, not validate them
    - Think outside the box and put crazy ideas on table
2. Product surveys
    - Study existing products
    - Address shortcomings of existing solutions with new product
    - Use product manuals and other forms of documentation of existing system
    - Look at features and interactions of current products
3. Observation
    - Observe users in natural work environment
    - Uncover product requirements
    - Usage data of existing system, information on how it is being used
    - Find situations which current system makes it difficult for user
4. User surveys
    - Surveys to _solicit responses and opinions_ from large number of stakeholders
    - On current product, on new product
5. Interviews
    - Interview stakeholders and domain experts (expert of domain which product is connected to)
    - Gather useful information that project requires
6. Focus groups
    - A kind of informal interview within interactive group setting
    - Ask group of people about their understanding of a specific issue, process, product, advertisement etc
7. Prototyping
    - Mock up, scaled down version, partial system constructed
    - Get users' (quick) feedback
    - Validate technical concept ("proof-of-concept" prototype)
    - Give preview of what is to come, or to compare multiple alternatives on a small scale before committing fully to one alternative
    - Early field-testing under controlled conditions
    - Can be used to undercover requirements, particularly those related to _how users interact_ with system
    - E.g. wireframe diagram
    - Can serve as specification on what to build as well

# Requirement Techniques: **Specifying**

1. Prose
    * Textual description used to describe requirements
    * Useful when describing abstract ideas
        - E.g. vision of product
    * Avoid using lengthy prose, can be hard to follow
2. Feature lists
    * List of features of a product grouped according to some criteria
        - E.g. aspect, priority, order of delivery etc
    * Example:
<!-- -->
    // Minesweeper
    1. Basic play – Single player play.
    2. Difficulty levels
        - Medium-levels
        - Advanced levels
    3. Versus play – Two players can play against each other.
    4. Timer – Additional fixed time restriction on the player.
    5. ...

3. User stories
    * Short, simple descriptions of a feature told from **perspective** of the person who desires new capability, usually **user/customer** of system
    * Written in a natural language (not formal)
    * Do not contain enough details to form a complete system specification
    * Common format: `As a {user type/role} I can {function} so that {benefit}`
        - _user_, _function_, _benefit_
        - Can omit `{benefit}` if obvious
        - Recommended to confirm there is a concrete benefit even if omit if from user story (or else end up doing features that have no real benefit)
        - Can add more characteristics to `{user role}` to provide more context to user story
    - Can write stories on _various levels_
        - High-level user stories/epics/themes: cover bigger functionality
        - Break these down to multiple stories of normal size
    - Can add _conditions of satisfaction_ to user story
        - Specify things that need to be true for story to be accepted as 'done'
    - Other useful info that can be added
        - E.g. Priority: how important story is
        - E.g. Size: estimated effort to implement story
        - E.g. Urgency: how soon feature is needed
    * How:
        - Write on index cards/sticky notes
        - Arrange on walls/tables (facilitate planning, discussion)
        - Or use software (to manage digitally) which is better for longer-term management and if team not co-located
            - E.g. GitHub Project Boards, Google Sheets, Trello
    * Capture user requirements in a way that isconvenient for
        - Scoping (which features to include in product)
        - Estimation (how much effort each feature willtake)
        - Scheduling (when to deliver each feature)
    * Differ from traditional requirements specification (i.e. prose) in level of detail
        - Should only provide enough details to make reasonably low risk estimate of how long it will take to implement user story
        - Work out more detailed description of requirements when meeting customers face-to-face
    * Can capture non-functional requirements
    * Handy for recording requirements during early stages of requirements gathering
    * **Tips**:
        - Define _target user_ (profile and work patternss)
        - Define _problem scope_ (exact problem to solve)
        - Don't be too hasty to discard 'unusual' user stories (can make the product unique)
        - Don't go into too much details
        - Don't be biased by pre-conceived product ideas
        - Don't discuss implementation details or whether you are actually going to implement it
    * Examples:
<!-- -->
    // Learning Management System
    - As a student, I can download files uploaded by lecturers, so    that I can get my own copy of the files
    - As a lecturer, I can create discussion forums, so that  students can discuss things online
    - As a tutor, I can print attendance sheets, so that I can take   attendance during the clas

    // More characteristics to user role
    - As a **forgetful** user, I can view a password hint, so that I can recall my password.
    - As an **expert** user, I can tweak the underlying formatting tags of the document, so that I can format the document exactly as I need
    
    // Example of an epic
    [Epic] As a lecturer, I can monitor student participation levels

    - As a lecturer, I can view the forum post count of each student
    so that I can identify the activity level of students in the    forum
    - As a lecturer, I can view webcast view records of each student
    so that I can identify the students who did not view webcasts
    - As a lecturer, I can view file download statistics of each  student
    so that I can identify the students who do not download     lecture materials

    // Example of a user story with conditions of satisfaction
    As a lecturer, I can view the forum post count of each student so that I can identify the activity level of students in the forum.

    Conditions:

    [v] Separate post count for each forum should be shown
    [] Total post count of a student should be shown
    [v] The list should be sortable by student name and post count

4. Glossary
    * Ensures that all stakeholders have a **common understanding** of noteworthy terms, abbreviations, acronyms etc.
5. Supplementary Requirements
    * A section used to capture requirements that do not fit elsewhere
    * Typically where non-functional requirements listed

# Code Quality

* Dimensions of code quality
    - Run-time efficiency
    - Security
    - Robustness
    - **understandability** (important)
* Learn to follow a standard (objective)
* Comments
    - If you must
    - wrong, tests don't check code, may not be updated
    - good code that are self-explanatory don't really need comments that explain the code 
    - Need comments to explain what the code does, at a higher level
* Avoid magic literals
    - E.g.`SUBSIDY` instead of `250`
* Exploit abstraction
    -SLAP (single level of abstraction per function)
        - Same level of abstraction within a method
    - Use guard conditions
        Reduce nesting of happy path (i.e. main method) of code
* Optimise, if you must
* Messy things get messier
    - Clean up code **frequently**
    - Refactoring
        - Improve program's internal structure
        - In _small_ steps
        - _Without_ modifying its external behaviour
* Below: ways to improve code quality

## 1. **Readability**
- Avoid long methods
    - Especially when method longer than computer screen
    - When beyond 30 LOC, take corrective action
    - The longer the code, the harder to debug
- Avoid deep nesting
    - Especially when need more than 3 levels of indentation
    - **Bad** example:
<!-- -->
    method() {
        if (...) {
            if (...) {
                if (...)
            }
        }
    }

- Avoid complicated expressions
    - Especially those with many negations and nested parentheses
    - If need to evaluate complicated expressions, do it in steps
    - Calculate intermediate values first, then use them to calculate final value
    - **Bad** example:
<!-- -->
    return ((length < MAX_LENGTH) || (previousSize != length)) && (typeCode == URGENT);
    // Change using isWithinSizeLimit, isSameSize, isValidCode

- Avoid magic literals
    - Magic Numbers: numbers that does not explain the meaning of the number
    - Use named constant (e.g. `PI`)
    - Names tells us more about the meaning of the number
    - Same goes for magic strings
- Make the code obvious
    - Make code as explicit as possible, even if language allows it to be implicit
    - Examples:
        - [`Java`]: Use explicit type conversion instead of implicit type conversion
        - [`Java`, `Python`]
            - Use parentheses/braces to show grouping even when they can be skipped
            - Use enumerations when certain variable can take only a small number of finite values
-----
- Structure code logically
    - Code should read like story
    - Use classes, methods, indentation and line spacing to group related segments of code
    - Affects clarity of readability
- Do not 'trip up' the reader
    - Avoid things that would make the reader go 'huh?'
    - Avoid
        - Unused parameters in method signature
        - Similar things that look different
        - Different things that look similar
        - Multiple statements in the same line
        - Data flow anomalies like pre-assigning values to variables and modifying it without any use of pre-assigned value
- Practice KISSing
    - KISS: Keep it Simple, Stupid
    - Do not try to write 'clever' code
    - Do not dismiss brute-force but simple solutions just because of 'better reusability' unless there is a strong justification
- Avoid premature optimisations
    - Several drawbacks
    - May not know which parts are the real performance bottlenecks
        - Especially when code undergoes transformations before becoming an executable
        - E.g. compiling, minifying, transpiling etc
        - Ideally, use profiler tool to identify actual bottlenecks first then only optimise those parts
    - Optimising can complicate code
        - Make it hard to understand and affect correctness
    - Hand-optimised code can be harder for compiler to optimise
       - In many cases, compiler can do a better job of optimising runtime code
    - **Make it work, make it right, make it fast**
        - Code performing correctly takes priority
    - Cases when optimising takes priority over other things
        - When writing code for resource-constrained environments
        - Optimise when only _really_ needed
- SLAP hard
    - SLAP: Single Level of Abstraction Per Method
    - Avoid varying level of abstractionn within code fragment
    - 
- Make the Happy Path Prominent
    - Happy Path: the execution path taken when everything goes well
    - Make it clear and prominent
    - Restructure code, make it unidented as much as possible
    - 'Unusual' cases are the ones that should be unindented
    - Someone reading code should not be distracted by alternative paths taken when error conditions happen
    - Use **guard clauses**
<!-- -->
    // BAD
    if (...) {
        if(...) {
            // main path
        } else {
            // unusual condition
        }
    } else {
        // unusual condition
    }

    // GOOD
    if (...) {
        // handle unusual case
        return;
    }
    if (...) {
        // handle unusual case
        return;
    }

    // main path execution

## 2. **Naming**

* Proper naming
* Improves readability
* Reduces bugs caused by ambiguities regarding intent of variable or method
-----
- Use nouns for Things and verbs for Actions
    - Classes, variables: use nouns
    - Methods, functions: verbs
    - Distinguish clearly between single-values and multi-valued variables
        - e.g. `student` vs `students` for a list
- Use standard words
    - Avoid 'texting-style' spelling
    - Avoid foreign words, slang, names that are meaningful within specific contexts/times
- Use name to explain
    - Name can differentiated, can also explain the named entity accurately and at a sufficient level of detail
    - **BAD** examples
        - `processInput()` (what 'process'?), `flag`, `temp`
    - If name has multiple words, they should in a sensible order
    - Don't use numbers or case to distinguish names
- Not too long, not too short
    - Not preferable to have names that are too short (worse than lengthy names)
    - If must abbreviate or use acronyms, do it **consistently**
    - Explain their full meaning at an obvious location
- Avoid misleading names
    - Related things should be named similarly
    - Unrelated things should **not** be named similarly
        - E.g. `redBooks`, `readBooks`
    - Avoid ambiguous names
        - Names with multiple meanings
        - Names with similar sounding names
        - Hard-to-pronounce names
        - E.g. lowercase L, capital I or number 1?
        - E.g. number 0 or letter O?
    - Spell out numbers (e.g. `phaseZero` instead of `phase0`)
    - E.g. `rightDirection`, `leftDirection` instead of `right`, `left` `

## 3. **Unsafe practices**

* Safer to use language constructs in the way they are meant to be used
* Prone to error using shortcuts
-----
- Use default branch
    - Always include in `case`, `if-else` statements
    - Use it for intended `default`/`else` action, not to execute last option
    - If no default action, use it to detect errors (e.g. throw exception)
    - Do not use `else` when `if` condition explicitly specified
    - Example:
<!-- -->
    // BAD
    if (red) print "red";
    else print "blue";
    
    // GOOD
    if (red) print "red";
    else if (blue) print "blue";
    else error("incorrect input");

- Don't recycle variables or parameters
    - Use one variable for one purpose
    - Do not use formal parameters as local variables inside method
<!-- -->
    // BAD
    double computeRectangleArea(double length, double width) {
        length = length * width;
        return length;
    }

    // GOOD
    double computeRectangleArea(double length, double width) {
        double area;
        area = length * width;
        return area;
    }

- Avoid empty catch blocks
    - Never write an empty `catch` statement
    - At least give a comment to explain why it is empty
- Delete dead code
    - Get rid of unused code the moment it becomes redundant
    - If need code again, simply recover using revision control tool
    - Deleting code you wrote previously is a sign that you are improving
-----
- Minimise scope of variables
    - Minimise global variables
        - They create implicit links between code segments that use global variable
        - Avoid as much as possible
    - Define variables in the least possible scope
        - If only used within a block, declare inside that block
        - Declare variable where it is first used
- Minimise code duplication
    - Copy-paste-modify code often indicates a poor quality implementation
    - Not possible to always have zero duplication but think twice before duplicating code
    - There is always a better alternative
    - DRY (Don't Repeat Yourself) principle



## 4. **Code comments**

* Avoid writing comments to explain bad code
* Improve code to make it self-explanatory
* Ask yourself how to improve code so that comment isn't needed? (Steve McConnell)
-----
- Do not repeat the obvious
    - Refrain from repeating description if code is self-explanatory
- Write to the reader
    - Write comments well enough to be understood by another programmer
    - E.g. _header comment_ to explain purpose of a class or an operation: `/** Trims the input of leading ...*/`
- Explain WHAT and WHY, not HOW
    - WHAT
        - Specification of what the code is _supposed_ to do
        - Reader can compare such comments to implementation to verify if correct
    - WHY
        - Rationale for current implementation
        - E.g. reason for calling a certain method
        - E.g. `// Remove spaces to comply with ... formatting rules`
    - HOW (**BAD**)
        - Explanation of how code works
        - Redundant
        - Refactor code instead

# Refactoring

    // TODO

# Assertions (Java `assert`)

* Used to define assumptions about program state so that runtime can verify them
* Example: _When the execution comes to this point, the variable **v** cannot be null_
* Assertion failure
    - Indicate possible bug in code
    - Code result in program state violates assumption about how code _should_ behave
* When runtime detects an assertion failure
    - Take some drastic action
    - E.g. terminate execution with error message
    - The sooner the execution stops, the safer it is
* Code implementation: 
    - keyword `assert`
<!-- -->
    x = getX();
    // If x is not 0 at this point, assertion will fail with given message
    assert x == 0 : "x should be 0";
    ...

* Can disable assertions without modifying code (default)
<!-- -->
    // Method 1 (run assertions)
    java -enableassertions HelloWorld
    // Method 2
    java -ea HelloWorld
    // Run without verifying assertions (default)
    java -disableassertions HelloWorld

* Enable assertions in Intellij, confirm assertions are being verified
    - Insert `assert false`
* Difference with JUnit assertions
    - Java `assert` similar in purpose
    - But JUnit assertions more powerful, customised for testing
    - Junit assertions not disable by default
    - Where to use
        - JUnit assertions: in test code
        - Java `assert`: in functional code
* Use liberally in code
    - Low impact on performance
    - Worth the additional safety they provide
* Do **not** use assertions to do _work_
    - Because assertions can be disabled
    - Program will stop working when assertions are not enabled
    - If method is performing some work necessary for program, program will not work correctly when assertions disabled
    - Example:
<!-- -->
    ...
    assert writeFile() : "File writing is supposed to return true

* Suitable for verifying assumptions about
    - Internal Invariants
    - Control-Flow Invariants
    - Preconditions
    - Postconditions
    - Class Invariants
* Complementary with exceptions in handling errors in software
    - But serve different purposes
    - Both should be used in code
    - Raising an exception
        - Indicates an unusual condition created by user or environment
        - Exceptions should **not** **terminate** program
        - E.g. user inputs an unacceptable input
        - E.g. file needed for program is missing
    - Assertion failure
        - Indicates programmer made a mistake in code
        - E.g. Null value returned from method that is not supposed to return null under any circumstances

# Java: **_lambdas_** and **_streams_**

* Java 8 new features
* [Link](https://winterbe.com/posts/2014/03/16/java-8-tutorial/)

## _**lambdas**_

* Adds functional processing capability to Java
* Syntax: `parameter -> expression body`
* Optional in syntax
    - Type declaration
        - No need to declare type of a param
        - Compiler can inference the same from value of param
    - Parenthesis around parameter
        - No need to declare a single param in parenthesis
        - Although required for multiple params
    - Curly braces
        - No need to use in expression body if body contains single statement
    - Return keyword
        - Compiler automatically returns value if body has single expression to return value
        - Need curly braces to indicate that expression returns a value
* Primarily used to define inline implementation of a functional interface (i.e. interface with a single method)
* Eliminates the need of anonymous class
* Lambda expression throws a compilation error, if variable assigned a value the second time
* Example 1:
<!-- -->

    import java.util.Collections;
    import java.util.List;
    import java.util.ArrayList;
    import java.util.Comparator;

    public class Java8Tester {

    public static void main(String args[]) {
    
        List<String> names1 = new ArrayList<String>();
        names1.add("Mahesh ");
        names1.add("Suresh ");
        names1.add("Ramesh ");
        names1.add("Naresh ");
        names1.add("Kalpesh ");
            
        List<String> names2 = new ArrayList<String>();
        names2.add("Mahesh ");
        // ...
            
        Java8Tester tester = new Java8Tester();
        System.out.println("Sort using Java 7 syntax: ");
            
        tester.sortUsingJava7(names1);
        System.out.println(names1);
        System.out.println("Sort using Java 8 syntax: ");
            
        tester.sortUsingJava8(names2);
        System.out.println(names2);
    }
    
    //sort using java 7
    private void sortUsingJava7(List<String> names) {   
        Collections.sort(names, new Comparator<String>() {
            @Override
            public int compare(String s1, String s2) {
                return s1.compareTo(s2);
            }
        });
    }
    
    //sort using java 8
    private void sortUsingJava8(List<String> names) {
        Collections.sort(names, (s1, s2) -> s1.compareTo(s2));
    }
    }

    // Output using Java 7, 8 syntax
    // [ Kalpesh Mahesh Naresh Ramesh Suresh ]

* Example 2:
<!-- -->
    //with type declaration
    MathOperation addition = (int a, int b) -> a + b;
    System.out.println("10 + 5 = " + tester.operate(10, 5, addition)) ;	
    
    //with out type declaration
    MathOperation subtraction = (a, b) -> a - b;	
    
    //with return statement along with curly braces
    MathOperation multiplication = (int a, int b) -> return a * b;  };	
    
    //without return statement and without curly braces
    MathOperation division = (int a, int b) -> a / b;

    //without parenthesis
    GreetingService greetService1 = message ->
    System.out.println("Hello " + message); 	
    greetService1.sayMessage("Mahesh");
    
    //with parenthesis
    GreetingService greetService2 = (message) ->
    System.out.println("Hello " + message);

* Example 3:
<!-- -->
    // Can read final local variables from outer scope of lambda expression
    final int num = 1;
    // OR, no need to declare final
    int num = 1
    Converter<Integer, String> stringConverter =
            (from) -> String.valueOf(from + num);

    stringConverter.convert(2);

* Example 4:
<!-- -->
    // this does not compile (num must be implicitly final)
    // cannot write to num from within lambda expression also
    int num = 1;
    Converter<Integer, String> stringConverter =
            (from) -> String.valueOf(from + num);
    num = 3;

## _**streams**_

* Stream API `java.util.Stream`
* Facilitate pipeline processing
* Represents a sequence of elements where one or more operations can be performed
    - _sequence of elements_: a set of elements of a specific type in a sequential manner
    - A stream gets them on demand, never stores them
* Stream operations either _intermediate_ or _terminal_
    - _intermediate_: return stream itself such that multiple method calls can be chained in a row
    - _terminal_: return a result of a certain type
* Streams created on input sources (e.g. `java.util.Collection` like lists, sets, **not** maps)
* Stream operations can be executed sequentially or in parallel

### **1. `stream()`**

* Returns a sequential stream considering collection as its source
* Example (**_filter_**):
    - Filter accept a predicate to filter all elements of stream
    - This operation is _immediate_
    - Another stream operation _forEach_
    - It accepts a consumer to be executed for each element in filtered stream
    - It is a terminal operation and is _void_, so cannot call another stream operation
<!-- -->
    stringCollection
        .stream()
        .filter((s) -> s.startsWith("a"))
        .forEach(System.out::println);

    // "aaa2", "aaa1"

* Example (**_sorted_**):
    - `sorted` is _intermediate_ operation, returns sorted **view** of stream
    - Ordering of backed collection is not manipulated, `stringCollection` ordering is still same
    - Elements sorted in natural order unless pass in a custom `Comparator`
<!-- -->
    stringCollection
        .stream()
        // 
        .sorted()
        .filter((s) -> s.startsWith("a"))
        .forEach(System.out::println);

    // "aaa1", "aaa2"

* Example (**_map_**):
    - `map` is an intermediate operation, converts each element into another object via given function (can also transform each object into another type)
<!-- -->
    stringCollection
        .stream()
        .map(String::toUpperCase)
        .sorted((a, b) -> b.compareTo(a))
        .forEach(System.out::println);

    // "DDD2", "DDD1", "CCC", "BBB3", "BBB2", "AAA2", "AAA1"

* Example (**_match_**):
    - Check if a certain predicate matches the stream
    - All matching operation are _terminal_, return boolean result
    - Examples: `.anyMatch()`, `.allMatch()`, `.noneMatch()`
<!-- -->
    boolean anyStartsWithA =
        stringCollection
            .stream()
            .anyMatch((s) -> s.startsWith("a"));

    System.out.println(anyStartsWithA);      // true

    boolean allStartsWithA =
        stringCollection
            .stream()
            .allMatch((s) -> s.startsWith("a"));

    System.out.println(allStartsWithA);      // false

    boolean noneStartsWithZ =
        stringCollection
            .stream()
            .noneMatch((s) -> s.startsWith("z"));

    System.out.println(noneStartsWithZ);      // true

* Example (**_count_**):
    - `count` is a terminal operation, returns the number of elements in the stream as a `long`
<!-- -->
    long startsWithB =
        stringCollection
            .stream()
            .filter((s) -> s.startsWith("b"))
            .count();

    System.out.println(startsWithB);    // 3

* Example (**_reduce_**):
    - `reduce` is a terminal operation that performs a reduction on elements of the stream with given function
    - Returns an `Optional` holding the reduced value
<!-- -->
    Optional<String> reduced =
        stringCollection
            .stream()
            .sorted()
            .reduce((s1, s2) -> s1 + "#" + s2);

    reduced.ifPresent(System.out::println);
    // "aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2"



### **2. `parallelStream()`** 

* Returns a parallel Stream considering collection as its source
* Operations on parallel streams performed concurrent on multiple threads
* Increases performance, especially for a large list
* Notation: `.parallelStream()`
* Example:
<!-- -->
    long count = values.parallelStream().sorted().count();

# Continuous Integration/Deployment

* Integration: combining parts of a software product to form a whole
* Continuous integration (CI): extreme application of build automation
    - After each code change, integration, building, testing happens automatically
* Continuous Deployment (CD): natural extension of CI
    - Changes integrated continuously, and also deployed to end-users at the same time
* Examples of CI/CD tools
    - Travis, Jenkins, Appveyor CircleCIs

## Build Automation

* Build automation tools
    - Automate steps of build process
    - Usually by build scripts
* Example of complex multi-step process of building a product from source code
    - Pull code from revision control system
    - Compile
    - Link
    - Run automated tests
    - Automatically update release documents (e.g. build number)
    - Package into a distributable
    - Push to repo
    - Deploy to a server
    - Delete temporary files created during building/testing
    - Email developers of new build
    - Etc.
* Can be scheduled (e.g. every day at midnight)
* Can be triggered by various events (e.g. triggered by a code push to revision control system)
* Popular build tools
    - Gradle, Maven, Aphache Ant, GNU Make (Java)
    - Grunt (JavaScript
    - Rake (Ruby))
* Build tools can also serve as _dependency management tools_
    - Depend on constantly evolving third party libraries
    - Need to download correct version of required libraries, update regularly
    - E.g. Maven, Gradle

# Other: Java aggregate operations and others

    // TODO

| Operation | Description | Example |
| --- | --- | --- |
| `filter` | Filter elements of stream based on predicate | `arrList.stream().filter((s) -> s.startsWith("a"))` |
| `sort` | Returns sorted _view_ of stream | `arrList.stream().sorted()` | 
| `map` | Converts each element into another object or into another type via given function | `arrList.stream().map(String::toUpperCase)` |
| `limit` | | |
| `reduce` | Performs a reduction on the elements of stream with given function, results is an `Option` holding reduced value | |
| `find` | | |
| `count` | Returns the number of elements in the stream as a `long` | `arrList.stream().count()` | 
| `match` | Checks whether a certain predicate matches the stream, returns a boolean result | `arrList.stream().anyMatch()` |
| | | `arrList.stream().allMatch()` |
| | | `arrList.stream().noneMatch()` |
| `forEach ` | Accepts a consumer to be executed for each element in the stream (returns _void_) | `arrList.stream().forEach(System.out::println)` |


