# CS2103 Notes (Week 9)

# Week 8 (Lecture - 11/10)

* Activity diagram
    - **Fork**
        - Indicates parallel paths
    - **Branch**
        - Only can have 2 paths from a branch
    - **Rakes**
        - Non-examinable
    - **Swim lanes**
        - Non-examinable
        - Add-on
        - Show _who_ is only doing what actions
* Open-Closed Principle (OCP)
    - Open for extension: Should be able to extend (use the same code and add-on to it) and use it
    - Closed for modification: should not modify the code itself
        - Because other things coupled to it might be affected by changes in code
* Liskov Substitution Principle
    - Must be substitutable for base classes
    - If parent class has some restrictions (e.g. can only accept number from 1 to 100)
    - Child class should **not** be more restrictive than the parent (e.g. can only accept number from 1 to 10)
* Law of Demeter
    - E.g. `//B` is not good because `Seller` should not know that the money is in the `Wallet` (money could be somewhere else)
    - Should be hidden within `getPayment()`
<!-- -->
    class Seller {
        void getPayment(Customer c, double amount) {
            // A
            Money payment = c.getPayment(amount);
            // B
            Money payment = c.getWallet().getPayment(amount);
        }
    }

-----

* **Sequential/Waterfall**
    - One phase produces something that leads/allows the start of the next phase
    - Initially buggy
        - E.g. box not stable
    - If requirements are well-understood, fixed and effort predictable
    - Especially if there is a high cost of deploying a 95% completed product
        - E.g. space shuttle 
* **Iterative**
    - If requirements fuzzy and evolving
    1. Iterative (breadth-first)
        - Product appears very fast
        - Initialise all components first
    2. Iterative (depth-first)
        - Appears component by 

------

* Agile processes
    - **NOT** 'high ceremony' processes (i.e. not heavy-weight)
    - E.g. XP (Extreme Programming), Scrum
* Scrum
    - Choose tasks to do in backlog
    - Complete in a sprint/iteration
        - Produce a potential product
    - Regulates the project
        - Pause and take stock
* Types of Documentation
    1. Tutorials
        - Teaching newcomer how to use app
    2. How-to Guides
        - Series of steps on achieving/completing a specific task
    3. Explanation
        - Helps to understand context, background, reasons
    4. Reference
        - Lots of information, describes structure, accurate, complete
    - Minimise (as much as necessary)
    - Top-down explaining
    - Docs from code, not writing it yourself (better chance of being updated)
    - UML Diagrams mainly used for communication
        - Don't expend unnecessary effort
    - Document only stable things
    - Comprehensible for guides
    - Comprehensive for references
    - Remember the purpose
        - tP: for explaining, communication, to be judged by reader, convey message
        - Adjust effort accordingly
        - Include several _types_ of diagrams
            - *What you could have done (possible alternative), explain with a different diagram


-----

# Object Oriented Domain Models (OO Domain Models)

* AKA **_conceptual class diagrams_** or **_OO domain models (OODMs)_**
* **Definition**: class diagrams which are used to model problem domain
    - analysis process of identifying objects and object classes
* Use class diagrams to model objects in _problem domain_ 
    - i.e. relevant information that is needed to analyse a problem
    - i.e. model how objects actually interact in real world before emulation in solution)
    - _vs_ class diagram (describe solution domain)
* OODMs do not contain solution-specific classes
    - i.e. classes that are used in the solution domain but don't exist in the problem domain
    - Example:
        - class `DatabaseConnection` in class diagram but not usually in OO domain model
        - Because `DatabaseConnection` is something related to a software solution but not an entity in the problem domain
* OODMs represent the _class structure_ of the problem domain
    - Not behaviour (shown by sequence diagrams)
* OODM notation is similar to class diagram notation
    - but typically omit methods and navigability (i.e. arrows)
* Examples: OO domain model of a snakes and ladders game
    - **Description**: Snakes and ladders game is played by two or more players using a board and a die. The board has 100 squares marked 1 to 100. Each player owns one piece. Players take turns to throw the die and advance their piece by the number of squares they earned from the die throw. The board has a number of snakes. If a player’s piece lands on a square with a snake head, the piece is automatically moved to the square containing the snake’s tail. Similarly, a piece can automatically move from a ladder foot to the ladder top. The player whose piece is the first to reach the 100th square wins.

    <img src = "./images/W9_OODM_ex.PNG" >

# Activity Diagrams

* Software projects often involve _workflows_
    - Define the flow in which a process or a set of tasks is executed
    - Understanding workflow is important for success of software project
* Examples where workflow relevant to software project
    1. Software automates work of an insurance company
        - Takes into account workflow of processing an insurance claim
    2. Algorithm of a price of code represents the execution flow (i.e. workflow) of the code
* **UML _activity diagrams_ (AD)**
    - Model workflows
    - UML equivalent of flow charts
* Example:

    <img src = "./images/W9_activity_diag_ex.PNG" >

* **Linear Paths**
    - AD captures an _activity of actions and control flows_ that make up the activity
    1. _action_
        - Single step in an activity
        - Notation: rectangle with **rounded corners**
        - Examples: `take to cashier`, `put back`, `buy`
    2. _control flow_
        - Shows flow of control from one action to the next
        - Notation: line with **arrow-head** to show direction of flow
        - There cannot be any double-headed arrows
    3. _start, end node_
        - Represents the start and end of an activity, respectively
        - **Note** difference between the nodes
    - Notation example:

    <img src = "./images/W9_activity_diag_linearpath.PNG" >
    
    - An activity can have only one action (i.e. one rounded-corner rectangle)

* **Alternate Paths**
    - _branch node_
        - Shows start of alternate paths
            - There can be more than 2 alternate paths
            - An alternate path can divide into more branches
            - A branch can join other branches

            <img src = "./images/W9_activity_diag_altpaths_ex1.PNG">
            
            - A branch can form a loop by going back to the original branch node
            
            <img src = "./images/W9_activity_diag_altpaths_ex2.PNG">
        
        - _guard condition_
            - Each control flow exiting branch node has one
            - A boolean condition that should be true for execution to take that path
            - Only one guard condition can be true at any time
            - Notation: **square brackets**
            - Examples: `[Customer likes product]`, `[else]`
    - _merge node_
        - Shows end of alternate paths
    - Notation: diamond shape
    - Notation example:

    <img src = "./images/W9_activity_diag_altpaths.PNG" >

* **Parallel Paths**
    - _fork nodes_
        - Indicate the start of concurrent flows of control
    - _join nodes_
        - Indicate end of parallel paths
    - Notation: a horizontal bar
    - In a set of parallel paths (i.e. paths with matching fork-join pair), execution along all parallel paths should be complete before execution can start on the outgoing control of _join_
        - i.e. Both parallel path of activities needs to finish before any activity after _join node_ can take place
        - i.e. All parallel paths that started from a fork should end in the **same** join node
    - -A parallel path can have multiple actions
    - Notation example:

    <img src = "./images/W9_activity_diag_parallelpaths.PNG">

* **Rakes**
    - Indicate that a part of the activity is given as a separate diagram
        - i.e. Action is described in another subsidiary activity diagram elsewhere
    - Notation: _rake symbol_ in an _action_ rectangle
    - Example:

    <img src = "./images/W9_activity_diag_rake_ex_p1.PNG">
    <img src = "./images/W9_activity_diag_rake_ex_p2.PNG">

* **Swim Lanes**
    - _Swimlane diagrams_ are partitioned activity diagrams
    - Partition an activity diagram to show who is doing what action
    - Example:

    <img src = "./images/W9_activity_diag_swimlane.PNG">

-----

# Design Principles

1. Single Responsibility Principle (SRP)
    - A class has one and only one reason to change
    - Class has only one responsibility, needs to change only when there is a change to that responsibility
    - Gather together things that change for the same reasons
    - **Bad** Example:
        - `TextUi` class does parsing of user commands, interacts with user
        - Class needs to change when formatting of UI changes, syntax of user command changes
        - Not following SRP

2. Open-Closed Principle (OCP)
    - A module should be _open_ for extension for _closed_ for modification
    - Modules should be written so that they can be extended, without requiring them to be modified
    - **Should be able to change a software's module's behaviour without modifying its code**
    - Aims to make a code entity easy to adapt and reusable without needing to modify the code entity itself
    - Achieved through, separating _specification/interface_ from its _implementation_
    - Example 1:
        - Behaviour of `CommandQueue` class can be altered by adding more concrete `Command` subclasses
        - If add `Delete` class to delete commands, no need to modify code (just add alongside `List`, `Sort`, `Reset`)
        - Hence behaviour of `CommandQueue` was extended without having to modify its code
    - Example 2:
        - Alter behaviour of Java generic class by passing it a different class as a parameter
        - `ArrayList` class behaves as a container of `Students`, and a container of `Admin` objects
        - 2 containers, no need to change code
        - Behaviour of `ArrayList` extended

3. Separation of Concerns Principle (SoC)*
    - To achieve better modularity, separate code into distinct sections, such that each section addresses a separate _concern_
    - _Concern_
        - A **set of information** that affects the **code of a computer program**
        - Examples:
            - A specific feature, such as code related to `add employee` feature
            - A specific aspect, such as code related to `persistence` or `security`
            - A specific entity, such as code related to `Employee` entity
    - Should lead to higher cohesion, lower coupling
    - Apply SoC to reduce functional overlaps among code sections and also limits the ripple effect when changes are introduced to a specific part of the system
        - A change to a class will not need changes to another class
    - SoC principle can be applied at class level, as well as on higher levels
        - _n-tier architecture_ uses SoC principle
        - AKA _multi-layered_, _layered_

        <img src = "./images/W9_ntier_archi.PNG">

        - Higher layers make use of services provided by lower layers
        - Examples, used in: operating systems, network communication software

        <img src = "./images/W9_ntier_archi_ex.PNG">

        - Each layer in architecture has well-defined functionality, no functional overlap with each other

4. Liskov Substitution Principle (LSP)
    - Derived classes must be substitutable for their base classes
    - Goes beyond substitutability
    - **Implies that a subclass should not be more restrictive than the behaviour specified by superclass**
        - i.e. Subclass does not impose more restrictive conditions than its parent class
    - If not followed, substituting a subclass object for a superclass object than break functionality of code in Java
        - i.e. code that worked with parent class may not work with child class

5. Law of Demeter (LoD)**
    - An object should
        1. Have only limited knowledge of another object
        2. Only interact with objects that are closely related to it
    - Also known as
        - Don't talk to stranger
        - Principle of least knowledge
    - Method `m` of object `O` should invoke only methods of the following kinds of objects
        - Object `O` itself
        - Objects passed as parameters of `m`
        - Objects created/instantiated in `m` (directly/indirectly)
        - Objects from the direct association of `O` (i.e. objects held by instance variables of `O`)
    - Aims to prevent objects navigating internal structures of other objects
    - **BAD** example (violate LoD)
        - MineSweeper example
        - In `Logic` class
        - Inside `setMinefield(Minefield mf): void`
        - Has `mf.getCell(1,3).clear()`
            - Violate LoD, `Logic` is handling `Cell` objects deep inside `Minefield`
            - Should be `mf.clearCellAt(1,3)`
    - **BAD** example
        - `b` is a 'friend' of `foo` (because receives it as a parameter)
        - `g` is a 'friend of a friend' (considered as 'stranger`)
        - `g.doSomething()` (talking to a 'stranger')
<!-- -->

    void foo(Bar b) {
        Goo g = b.getGoo();
        g.doSomething();
    }

6. Interface Segregation Principle (ISP)
    - No client should be forced to depend on methods it does not use
    - Example:
        - `Payroll` class should not depend on `AdminStaff` class since it does not use `arrangeMeeting()` method
        - Should depend on `SalariedStaff` interface
<!-- -->
    public class Payroll {
        //...    
        private void adjustSalaries(AdminStaff adminStaff){ //violates ISP
            //...
        }
        private void adjustSalaries(SalariedStaff staff){ //does not violate ISP
            //...
        }    
    }

<img src = "./images/W9_ISP_ex.PNG">


7. Dependency Inversion Principle (DIP)
    1. High-level modules should not depend on low-level modules, both should not depend on abstractions
    2. Abstractions should not depend on details, details should depend on abstractions
    - Changes the direction of dependencies, not reduce it
    - Can introduce extra abstractions, but worth it
    - Example:

    <img src = "./images/W9_DIP_ex.PNG" >

8. SOLID Principles
    - **(S)**: Single Responsibility principle (SRP)
    - **(O)**: Open-Closed Principle (OCP)
    - **(L)**: Liskov Substitution Principle (LSP)
    - **(I)**: Interface Segregation Principle (ISP)
    - **(D)**: Dependency Inversion Principle (DIP)

9. YAGNI Principle
    - _You Aren't Gonna Need it!_ principle
    - Do not add code simply because 'you might need it in the future'
    - Should not build some capability we presume software will require in the future
    - Rationale: we do not have perfect information about the future, extra work we do to fulfill a potential future need might go to waste when some of our predictions fail to materialise

10. DRY Principle
    - _Don't Repeat Yourself_ principle
    - Every piece of knowledge must have a single, unambiguous, authoritative representation within a system
    - Guards against the duplication of information
    - Examples of violations
        - Functionality implemented twice (even if 2 implementations are different, purpose is the same)
        - Defining a value of a system-wide timeout in multiple places

11. Brooks' Law
    - Adding people to a late project will make it later
    - By Fred Books
    - Additional communication overhead will outweigh the benefit of adding extra manpower, especially if done near a deadline
    - Slow-down of project (for a short period, maybe for smaller projects)
    - New member needs time to learn the project, existing members need to spend time helping new member
    - Could delay project delivery is project is behind schedule and near a deadline

-----

# Conceptualising a Design

# SDLC Process Models

* Sequential Models
* Iterative Models
* Agile Models

-----

1. Scrum
2. XP
3. Unified Process
4. CMMI

# Writing Developer Documents

* Technical documents to help others understand technical details
* 2 forms of Developer-to-Developer documentation
    1. for **_developer-as-user_**
        - Document how software components are to be used
        - So that other developers can reuse them
        * **1.1 API documentation**
            - APIs expose functionality in small-sized, independent and easy-to-use chunks
            - Each can be documented systematically
            - Explaining functions/methods independently
            - Useful for both developers who use API and developers who maintain API implementation
            - There are tools that can generate API documents from code comments
            - Can contain code examples
        * **1.2 Tutorial-style instructional documentation**
            - Higher-level explanations of how to use an API usefully
    2. for **_developer-as-maintainer_**
        - Document how system/component is designed, implemented and tested
        - So that other developers can maintain, evolve code
        - Need to explain complex internal details
        - Only _some_ information need to be included since developer would have access to source code
        - Complementary source of information
            - Code
            - Code comments
* 4 things needed to write good documentation
    - 4 different purposes/functions
    - 4 different approaches required

| S/N | Documentation | | Analogy |
| --- | --- | --- | --- |
| 1 | Tutorials | - Learning-oriented | **Teaching** a small child how to cook |
| | | - Allows newcomer to get started | |
| | | - Is a lesson | |
| 2 | How-To Guides | - Goal-oriented | A **recipe** in a cookery book |
| | | - Shows how to solve a specific problem | |
| | | - Is a series of steps | |
| 3 | Explanation | - Understanding-oriented | An article on culinary social history |
| | | - **Explains** | |
| | | - Provides background and context | |
| 4 | Reference guide | - Information-orientation | A reference encyclopedia article |
| | | - Describes the machinery | |
| | | - Is accurate and complete | |

## **3 Guidelines**

1. Aim for Comprehensibility
    - Readily understood
    - Not just accurate and comprehensive
    - **Use plenty of diagrams**
        - Complement words with visual illustrations
        - E.g. UML diagram
    - **Use plenty of examples**
        - When explaining algorithms, show a running example
        - Illustrate each step of algorithm, in parallel to worded explanations
    - **Use simple and direct explanations**
        - Avoid long sentences, convoluted explanations, fancy words
    - **Get rid of statements that do not add value**
        - E.g. 'We made sure our system works perfectly'
        - E.g. 'Component X has its own responsibilities'
    - **Not good to have a separate section for each type of artifact**
        - Don't have separate sections for each type of diagrams
        - **Bad examples:** `'use cases'`, `'sequence diagrams'`, `'activity diagram'` etc
        - Don't separate diagrams from words
        - Need words to justify need for diagram, explain it
        - If want to provide additional diagrams for completeness' sake, include them in appendix as reference
2. Describe Top-Down
    - Top-down **breadth-first** explanation
    - Advantages
        - Document structured like an upside down tree (root at top)
        - Reader can travel down a path he/she interested in until reaching component interested to learn in-depth
        - No need to read entire document/understand whole system
        - Example:
            -  Explain a system called `SystemFoo` with two sub-systems, `FrontEnd` and `BackEnd`
            1. Start by describing the system at the highest level of abstraction, and progressively drill down to lower level details.
            - An outline for such a description is given below:
<!-- -->
    // [First, explain what the system is, in a black-box fashion (no internal details, only the **external view**).]

    `SystemFoo` is a ...

    // [Next, explain the high-level architecture of SystemFoo, referring to its **major components** only.]

    SystemFoo consists of two major components: FrontEnd and BackEnd.

    The job of FrontEnd is to ... while the job of BackEnd is to ...

    And this is how FrontEnd and BackEnd work together ...

    // [Now we can drill down to FrontEnd's **details**.]

    FrontEnd consists of three major components: A, B, C

    A's job is to ...
    B's job is to...
    C's job is to...

    And this is how the three components work together ...

    // [At this point, further drill down the **internal workings of each component**. A reader who is not interested in knowing nitty-gritty details can skip ahead to the section on BackEnd.]

    In-depth description of A ...

    In-depth description of B ...

    // [At this point drill down details of the BackEnd.]

    ...

3. Minimal but Sufficient

    - Aim for 'just enough' developer documentation
    - Minimise overhead of writing documentation
    - Documentation should complement code, should provide only just enough guidance to get started (if readers will eventually read the code)
    - **Focus on providing higher level information that is not readily visible in code or comments**
    - Try not to duplicate chunks/text
        - E.g. describing several similar algo/design/API
    - **Describe similarity in one place, emphasise only differences in other places**
        - Indicate differences between what looks like similar text
