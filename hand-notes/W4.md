# CS2103 Notes

# Week 4

### Models

* Representation of something else
* Provides simpler view of a complex entity, captures only a selected aspect
    - Models are abstractions
* **Class diagram**
    - Models that represents a software design
    - Captures the structure of software design but not the behaviour
* May need multiple models of same entity to capture it fully
* Purpose of models
    1. For analysis
        - Aid understanding of problem to solve
        - Models of problem domain/environment in which the software is expected to solve the problem
        - Helps to figure out how the solution is to be built
        - E.g. Architecture diagram
    2. To communicate information among stakeholder
        - Visual aid in discussion
        - Documentation
        - Explaining high-level design of software to developers
        - E.g. _Use case diagram_ to explain functionality
        - E.g. _Class diagram_ from reverse-engineering the code to explain design of component to new developer
    3. Blueprint for creating software
        - Used as instructions
* Model Driven Development (MDD)
    - Also called _Model-driven enginerring_
    - Approach to software development that strives to exploit models as blueprints
    - Use models as primary engineering artifacts when developing software
    - First model, then code
    - Conversion to code, code-generation techniques
        - Automated, semi-automated
        - Manual translation
    - Requires use of very expressive modeling notation (graphical or otherwise), often specific to given problem domain
    - Advantage
        - Same model can be used to create software for different platforms, languages


## UML Models

* Unified Modeling Language (UML)
* Graphical notation to describe various aspects of software system
* Current _de facto_ modeling notation used in software industry

In an OO solution,
| UML| _Object Diagrams_ | _CLass Diagrams_ |
| --- | --- | --- |
| Models | Object structures | Class structures |

## OO Structures

* Model how relevant objects are 'networked' together
* Object structures within same software can change over time
    - But do not change at random
    - Change based on set of rules
* Rules that object structures need to follow
    - Illustrated as a _class structure_
    - i.e. Structure that exists among relevant classes

## Class Diagrams

* Describe structure of an OOP solution
    - But not behaviour
* Basic UML notation to represent _class_:
<img src = "./images/W4_notation_class_diag.png" >
* Example:
<img src = "./images/W4_eg_class_diag.png" >
* May omit if such details not important:
    - _Attributes_ compartment
        - All attributes should be in one compartment
        - Can be empty
        - Has to be **above** operations compartment
    - _Operations_/_Methods_ compartment
        - All methods should be in one compartment
        - Can be empty
* _Visibility_ of attributes and methods
    - Indicate level of access allowed
    - Types of visibility and meaning depends on programming language used
<img src = "./images/W4_visibility_legend.png" >
* **Underline** denotes class-level attributes and variables
    - E.g. `totalStudents`, `getTotalStudents()`
* **Associations**
    - Main connections among classes in class diagram
    - Connections between objects
    - Can change over time
    - Associations among **objects** can be generalised as associations between corresponding classes too
    - Use instance level variables to implement associations
    - Exampls (**solid lines**):
    <img src = "./images/W4_basic_assoc_diag.png">
    - Addicaiton decorations
        - Adds information to class diagram
        1. Association labels
        2. Association roles
        3. Multiplicity
        4. Navigability

### Association Labels

* Describe the meaning of the association
* Notation: "label >"
    - Arrow head indicates direction in which label is to be read
* Example:

    <img src = "./images/W4_assoc_label.png" >

### Association Roles

* Assoc Role labels used to indicate role played by classes in the association
* Variable names match closely with association roles
    - E.g. `Woman wife` variable has `Woman` class with `wife` label
* Example:

    <img src = "./images/W4_assoc_roles.png">

### Multiplicity

* Aspect of OOP solution that dictates how many objects take part in each association
* Normal instance-level variable
    - `0..1` multiplicity (i.e. optional associations)
    - A variable can hold a reference to a single object or `null`
    - Example:
<!-- -->
    // Logic class has variable that can hold either 0 or 1 Minefield objects
    class Logic{
        Minefield minefield;
    }

    class Minefield{
        ...
    }

* Variable can be used to implement a `1` multiplicity
    - i.e. _compulsory association_
    - Example:
<!-- -->
    // Logic class will always have a ConfigGenerator object, provided the variable is not set to null at some point
    class Logic {
        ConfigGenerator cg = new ConfigGenerator();
        ...
    }

* Bi-directional associations require matching variables in both classes
    - E.g. Each object can have an association with an object of the other type
    - Example:
<!-- -->
    class Foo {
        Bar bar;
        //...
    }

    class Bar {
        Foo foo;
        //...
    }

* One-to-many associations
    - E.g. Array, ArrayLists, HashMaps, Sets etc.
* Notation

    <img src = "./images/W4_assoc_multiplicity.png">

| Notation | |
| --- | --- |
| `0..1` | _Optional_ (linked to 0 or 1 obj) |
| `1` | _Compulsory_ (linked to one obj at all times) |
| `*` | Linked to **0** or more obj |
| `n..m` | Number of linked objects must be `n` to `m` inclusive |

### Navigability

* Concept of which class in the association knows about the other class
    - 2 classes linked by an association do not necessarily know about each other
    - Knowing about the other class means that its object will hold an object of the other class in one of its variables
* Can be shown in both class and object diagrams
* Notation: arrow head
* Example (obj diag):

    <img src = "./images/W4_assoc_navigability_obj.png">
* Another example (class diag):

    <img src = "./images/W4_assoc_navigability_class.png">

## Object Diagrams

* Shows object structure at given point of time
* Can be used to complement class diagrams
    - E.g. Use them to model different object structures that can result from a design represented by a given class diagram (i.e may be able to translate obj diag to class diag)
* Notation: 
    - `objectName:ClassName`
        - Underlined
        - "an instance of `ClassName` identified as `objectName`
    - No compartment for methods
    - Can be omitted if not relevant
        - _Attributes_ compartment
        - Object name (if unnamed instance)

    <img src = "./images/W4_obj_diag_not.png">

## Object vs Class Diagrams

|| Object diag | Class diag |
| --- | --- | --- |
| Shows | objects | classes |
| | May have instance name | |
| | A `:` before class name | |
| | Underlined instance and class names | |
| Omitted (confirm) | Methods, multiplicities | |

* Multiple object diagrams can correspond to a single class diagram
    - The same class diagram can have many 'instances'
    - Example:

    <img src = "./images/W4_class_obj_diag.png">
