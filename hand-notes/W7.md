# CS2103 Notes Week 7

# Week 6 (Lecture - 20/9)

* iP
    - Asymmetric graphics for conversation
    - Since its not really a conversation between 2 people (echoing etc)
* Textual Use Cases
    - _Actor_
    - _Main success scenario_ (steps)
    - _Inclusion_
        - Underline
    - _Extensions_ 
        - E.g. extension to Step 3., as Step 3a.
* Visual Use Cases
    - Actor _generalisation_
        - Something like inheritance
    - Notation for _inclusion_: `--<<include>>-->`
    - Notation for _extension_: `--<<extend>>-->`
        - Not recommended to include
        - Too many to include
* Format
    - Vision
    - Scope
    - User
    - Workflow (broad summary of what each user does)
* API
    - Application Programming Interface
    - As long have a bunch of methods that can call
    - E.g. Application: GitHub
    - E.g. Class: `String`
    - Define APIs systematically to match features
        - Work backwards from features
* Agile Design Approach
    - Start with a minimal high-level design and evolve iteratively as necessary
    - Opposite: full design upfront
    - Because things change, just work on the things that need to be done
    - Decide only when you need a feature
* Design Fundamentals
    1. Abstraction
        - _"Abstraction is broken/leaking"_: Things that are meant to be hidden aren't
    2. Coupling
        - i.e. dependency
        - When
            - If change one class, might need a change in another class
            - If both classes assess the same global variable (not immediately obvious)
                - E.g. When modify content such that other class which uses it no longer works
        - Strong and weak dependency
        - Try to reduce
    3. Cohesion
        - About how tight something is, in a component
        - Increased cohesion, usually leads to better reusability
* Continuous Integration
    - Early and frequent integration, incrementally
    - Order of integration
        - Top-down, bottom-up (use drivers), sandwich (do both and meet halfway)
* Project
    - Build automation (Gradle)
    - Continuous integration (Travis)
    - Continuous deployment (builds a `jar` file every time it releases)
* Buffers
    - Not _padding_ (i.e. allocate more time to task)
    - If task not done by deadline, know that wrongly estimate time
* Forking workflow
    - Add a branch when adding something

# Requirements: Use Cases

* Describes an interaction between the user and te system for a specific functionality of the system
* Capture functional requirements of a system
-----
* Overview (**Textual form**)
<!-- -->

    System:
    Use case:
    Actor:
    Preconditions:
    Guarantees:
    MSS:
    Extensions:

-----
* Description of a set of sequences of actions
    - includes variants
* About actions that a system performs to yield an observable result of value to an actor
* Example:
    - _Check account balance_ use case for an ATM
<!-- -->
    System: ATM
    Actor: Customer
    Use Case: Check account balance
        1. User inserts an ATM card
        2. ATM prompts for PIN
        3. User enters PIN
        4. ATM prompts for withdrawal amount
        5. User enters the amount
        6. ATM ejects the ATM card and issues cash
        7. User collects the card and the cash.

* Use case diagrams illustrate use cases of a system visually
    - Provides a visual 'table of contents' of use cases of system
    - _Stick figures_: user roles relevant to use case
    - _Ovals_: use cases
    - Example:

    <img src = "./images/W7_use_case_diag_ex.PNG">

* Use case is an interaction between a system and its _actors_
* _Actor_
    - Role played by user
    - Reside outside the system
    - can be involved in many use cases
    - A single person/system can play many roles
    - Many persons/systems can play a single role
* A use case can
    - involve many actors
    - be specified at various levels of detail
    - E.g. `conduct a survey` > `take the survey` > `answer survey question`
* Tip while modeling user-system interactions
    - Start with high level use cases and progressively work toward lower level use cases
    - Be mindful at which level of details you are working on
    - Careful not to mix use cases of different levels
-----
* **Writing use case steps**
* Main body
    - Sequence of steps that describes the interaction between system and actors
    - Each step is given as a simple statement describing _who does what_
* Describe only the **externally visible** behaviour
    - Not internal details of system
    - Should minimise details that are not part of the interaction between user and system
* A step gives the intention of the actor
    - Not the mechanics
    - Usually omit UI details
* Use case description can show loops too
    - E.g. `Steps 5-9 are repeated for each Player, and for as many rounds as required until a Player reaches the 100th square`
* **Main Success Scenario (MSS)**
    - Describes most straightforward interaction for a given use case
    - Assumes that nothing goes wrong
        - E.g. all entered details correct
        - Ignore all problems
            - E.g. timeouts, network outages etc.
    - Also known as _Basic Course of Action_, _Main flow of Events_
* **_Extensions_**
    - "Add-on"s to the MSS that describe _exceptional_/_alternative_ flow of events
    - Describe variables of scenario if certain things are not as expected by MSS
    - Written notation: Appear below MSS (separate paragraph, keep MSS **self-contained**)
    - Numbering style not a universal rule but widely used convention
        - Extensions that only happen after a step of the MSS (E.g. `3a.`, `3b.`)
        - Extensions that can happen at any step (E.g.`*a.`)
    - Don't mention events likes power failures, system crashes as extensions because system cannot function beyond catastrophic failures
    - Diagram Notation: `<<extend>>` dashed arrows
        - Direction of arrow from extension to use case it extends
        - Extension Use Case Diagram Example:

        <img src = "./images/W7_use_case_diag_extension_ex.PNG">

        - Extention Use Case Example:
<!-- -->
    System: Online Banking System (OBS)
    Use case: UC23 - Transfer Money
    Actor: User
    MSS:
        User chooses to transfer money.
        OBS requests for details of the transfer.
        User enters the requested details.
        OBS requests for confirmation.
        OBS transfers the money and displays the new account    balance.
    Use case ends.

    Extensions:
        3a. OBS detects an error in the entered data.
            3a1. OBS requests for the correct data.
            3a2. User enters new data.
        Steps 3a1-3a2 are repeated until the data entered are correct.
        Use case resumes from step 4.

    3b. User requests to effect the transfer in a future date.
        3b1. OBS requests for confirmation.
        3b2. User confirms future transfer.
        Use case ends.

    *a. At any time, User chooses to cancel the transfer.
        *a1. OBS requests to confirm the cancellation.
        *a2. User confirms the cancellation.
        Use case ends.

    *b. At any time, 120 seconds lapse without any input from the   User.
        *b1. OBS cancels the transfer.
        *b2. OBS informs the User of the cancellation.
        // Okay to have multiple times of this
        // Okay to have multiple exit points for a use case
        Use case ends.

* Use case can **include** another use case
    - Useful when
        - Don't want to clutter a use case with too many low-level steps
        - A set of steps is repeated in multiple use cases
    - Diagram Notation: `<<include>>` dotted arrow
        - From use case that includes to use case that is being included (note opposite from `<<extend>>`)

            <img src = "./images/W7_use_case_diag_inclusion_ex.PNG">

    - Written notation: Underlined text

* **Preconditions**
    - Specify the specific state we expect the system to be in before use case starts
    - E.g. `Preconditions: User is logged in`
    - Example:
<!-- -->
    Software System: Online Banking System
    Use case: UC23 - Transfer Money
    Actor: User
    Preconditions: User is logged in
    MSS:

        User chooses to transfer money.
        OBS requests for details for the transfer.
        ...

* **Guarantees**
    - Specify what the use case promises to give us at the end of its operation
    - Like a postcondition
    - Optional
<!-- -->
    Software System: Online Banking System
    Use case: UC23 - Transfer Money
    Actor: User
    Preconditions: User is logged in.
    Guarantees:

        * Money will be deducted from the source account only if the  transfer to the destination account is successful
        * The transfer will not result in the account balance going   below the minimum balance required.
    
    MSS:

    1. User chooses to transfer money.
    2. OBS requests for details for the transfer.
        ...

* Can use actor generalisation in use case diagrams
    - Any child actor can do what a parent actor can do
    - Notation: arrow
        - Points from child actor to parent actor
        - Like UML notation for inheritance

        <img src = "./images/W7_use_case_diag_actor_generalisation.PNG">
* Tip: don't over-complicate use case diagrams
    - Don't try to include everything possible
    - Use case diagram is a brief summary of the use cases that is used as a starting point
    - Details of use cases given in use case descriptions
* Can include `System` as an actor
    - Indicate that something is done by system itself without being initiated by a user/external system
    - E.g. system generates daily reports at midnight
    - but **not recommended**
    - Limit use cases for modeling behaviours that involve external actor
* UML not very specific about the text contents of a use case
    - Many styles for writing
    - Steps should be written as a continuous paragraph
    - Should be easy to read
* Advantages
    - Document system requirements as use cases
    - Use simple notation, plain English; easy for users to understand and give feedback
    - Decouple user intention from mechanism; system designers (UI-specific details) more freedom to optimise how a functionality is provided to a user
    - Identify all possible extensions encourages us to consider all situations that a software product might face during its operation
    - Separate typical scenarios from special cases/exceptional usage scenarios; encourages us to optimise typical scenarios
* Disadvantages
    - Not good for capturing requirements that do not involve a user interacting with system
    - Not suitable for capturing non-functional requirements
    - Use cases should not be the sole means to specify requirements

# Design Principles: Basic

# Basic Design Approaches

* Multi-level design
* Full upfront design
* Which design to use depends on situtation
* Top-down Design
    - Design the high-level design first
    - Flesh out lower levels later
    - Useful when designing big and novel systems
    - Used when high-level design needs to be stable before lower levels can be desgined
* Bottom-up Design
    - Design lower level components first
    - Put them together to create higher-level systems later
    - Usually not scalable for bigger systems
    - Used when designing variations of an existing system, or, re-purposing existing components to build a new system (i.e. a lot of existing component to be reused)
* Mix Design
    - Mix of top-down, bottom-up design
* Agile Design
    - Emergent, not defined up front
    - Overall system design will emerge over time, evolve to fulfill new requirements, take advantage of new tech as appropriate (i.e. expects design to change over product's lifetime, architecture expected to remain relatively stable)
    - Do some initial architectual modeling at the beginning to get team going
    - No fully documented set of models in place before coding starts

# IDE: Intermediate Features

* Productivity shortcuts
* Reference shortcut helpsheet

# Integration Approaches

# Project Management: Scheduling and Tracking

# Project Management: Workflows

 