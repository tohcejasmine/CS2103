# CS2103 Notes (Week 6)

# Week 5 (Lecture - 13/9)

 * Doc comments should not include where the method will be used, because no control over it
 * Method doc comments
    - Verbs: _runs_, _constructs_
 * When defining methods, defining new vocabulary for readers
        - E.g. method name, variable names
        - Nouns and verbs
* SLAP
    - 2 levels is still all right
* Good code looks neat
* Learn smarter
    - Find out about things
    - At least what it does
    - When the time comes, can just find out more on how to use it
* Learn gradually at your own pace

## Modeling: Sequence Diagrams

* Interactions between components for a given scenario
* Self-call and call-backs
* Alternative paths (`if-else`) and optional paths (`if`)

## Modeling: Architecture Diagrams

* High-level structure
* Important technical decisions
    - E.g. servers
* Multi-level design
    - Class diagrams that do not span entire system
    - Instead OOP Component Design
    - For each component, focus only on it
        - Methods within it
    - Connect to components (i.e. classes) it calls with an arrow to a general box

## Product Design

* Personal, subjective observations about product design
* Everything you do should add value to the user
    - Not for your learning
* Minimise work for users
* Think from the user's point of view
    - To get the features
* Simple, the better
* Some users don't like flexibility and making choices
* Don't force users to read the user manual
    - Populate with well-chosen sample data
    - Contextual tups
    - Informative error messages
* Handle user input errors
* Focus on the benefits, not the features
* Visualise usage
    - Personas
    - Situation, context of use
    - First use: sample data? Tutorial?
    - Second and more use?
* Biggest aspect: **care** for the users
    - Figure out what users want
    - Main thing is that users have to like it

## Logging

* Keep record of what happen
* `log()`
    - E.g. `log(LEVEL_INFO, "Setting size to small")`
    - E.g.`log(LEVEL_WARN, "Size not recognised")`
* Can control what levels to show (e.g. when system is more developed, just show warnings)

## Breakpoints
* In IDE
* Specify the breakpoint
* Run program in debug mode
* Stops at breakpoint
* Shows values of variables at that point
* Can show values in next line etc.

## IDE Shortcuts

* `ctrl-Shift-v`: show list of things copied
* `ctrl-Shift-n`: find a method by search

# Modeling: UML Sequence Diagrams

* Diagram captures the interactions between multiple objects for a given scenario

<img src = "./images/W6_sequence_diag_not.png">

* Instance of a class
    * E.g. `:TextUI`: unnamed instance of class `TextUi`
    * E.g. `TextUi1:TextUi`, `TextUi2:TextUi`: 2 instances of `TextUi` which are distinguished by naming them
* **(Solid) Arrows**: represents method calls
* **(Dashed) Arrows**: represents method returns
* Class/object name **not** underline in sequence diagrams
* Common notation errors:
    1. _Activation bar too long_
        - Activation bar of a method canot start before the method call arrives
        - Method cannot remain active after method has returned
        - i.e. Arrows should connect at the start and end of activation bar (not middle)
        - Example: method `Foo#xyz()`
    <img src = "./images/W6_seq_diag_err1.png">
    2. _Broken activation bar_
        - Activation bar should remain unbroken from the point the method is called until method returns
    <img src = "./images/W6_seq_diag_err1.png">

## Loops

* Notation:

<img src = "./images/W6_seq_diag_loops_not.png">

* Example:
    - `Player` calls `mark x, y` command or `clear x y` command repeatedly until game is won or lost

<img src = "./images/W6_seq_diag_loops_ex.png"> 

## Object Creation

* Notation:
    1. **Arrow** that represents the constructor arrives at the side of box representing instance
    2. **Activation bar** represents period that constructor is active

<img src = "./images/W6_obj_creation_not.png"> 

## Object Deletion

* UML uses an `X` at the end of the lifeline of an object to show it's deletion
* Note: Although object deletion is not that important in languages (e.g. Java) that support automatic memory management, still can show deletion in UML diagrams to indicate the point at which the object ceases to be used
* Notation:

<img src = "./images/W6_obj_deletion_not.png"> 

## Self-Invocation

* Show a method of an object calling another of its own methods
* Notation:

<img src = "./images/W6_self_invocation_not.png">

* **_call back_**
    - Example:
    - `Book#write()` method calling `Chapter#getText()` which in turn does a _call back_ by calling `getAuthor()` method of calling object

<img src = "./images/W6_self_invocation_ex.png">

## Alternative Paths

* Use `alt` frames to indicate alternative paths
* Notation:

<img src = "./images/W6_alt_paths_not.png">

* For paths like `if-else` statements etc.
* Example:

<img src = "./images/W6_alt_paths_ex.png">

## Optional Paths

* Use `opt` frames to indicate optional paths
* Notation:

<img src = "./images/W6_op_path_not.png">

* Example:

<img src = "./images/W6_op_path_ex.png">

## Reference Frames

* UML uses _ref frame_ to allow **segment of interaction** to be omitted and shown as a separate sequence diagram
* Helps to:
    - break complicated sequence diagrams into multiple parts
    - simply omit details not interested in showing
* Kinda like referencing to another diagram that zooms in on the interactions
* Notation:

<img src = "./images/W6_ref_frame_not.png">

* Example:

<img src = "./images/W6_ref_frame_ex.png">

## Parallel Paths

* Use `par` frames to indicate parallel paths
* Note: If show parallel paths in a sequence diagram, the corresponding Java impementation is likely to be _multi-threaded_ because normal Java program cannot do multiple things at the same time
* Notation:

<img src = "./images/W6_par_path_not.png">

* Example
    - `Logic` calling methods `CloudServer#poll()` and `LocalServer#poll()` in parallel

<img src = "./images/W6_par_path_ex.png">


## Sequence Diagram: Questions

* Explain sequence diagram
* Draw sequence diagram for code snippet
* Explain interactions in sequence diagram
    - Example

    <img src = "./images/W6_seq_diag_q.png">


# Architecture Diagrams
## Reading
## Multi-Level Design

# IDEs: Basic Features
## Debugging
## Code Navigation

# Logging

* Deliberate recording of certain information during a program execution for future reference
* Typically written to a log file
    - Also possible to log information in other, e.g. into a database, remote server
* Useful for troubleshooting problems
    - Regularly record some system information
    - When bad things happen (e.g. unanticipated failure), associated log files may provide indication of what went wrong
    - Can take action prevent it from happening again
* Log file like a black box (flight data recorder) of an airplace
    - Don't prevent problems
    - But helpful in understanding what went wrong after the fact
* Most programming environments come with logging systems that allow sophisticated forms of logging
    - E.g. ability to enable, disable logging easily
    - E.g. ability to change logging intensity (how much info to record)
* Log message levels (descending order)
    - `SEVERE`, `WARNING`
    - `INFO`, `CONFIG`
    - `FINE`, `FINER`, `FINEST`
-----
* Guidelines to levels:
    - Default should be no lower than `info`
    - `fatal`: Severe errors that cause premature termination
        - Expect these to be immediately visible on status console
    - `error`: Other runtime errors or unexpected conditions
        - Also expect them to be immediately visible
    - `warn`: Use of deprecated APIs, other runtime situations
        - Poor use of API, 'almost' erros
        - Situations that are undesirable or unexpected but not necessarily 'wrong'
        - Also expect to be immediately visible
    - `info`: Interesting runtime events (start up/shut down)
        - Be conservative and keep to minimum
        - Also expect to be immediately visible
    - `trace`: More detailed information
<!-- -->
    // Java default logging mechanism
    import java.util.logging.*;
    // Create a Logger
    private static Logger logger = Logger.getLogger("classNameORloggerName");

    // Log information using Logger object
    // Logging level can be set
    logger.log(Level.INFO, "going to start processing");
    logger.log(Level.WARNING, "processing error", ex)

* Set logger to a certain level, such that all messages of that level and higher severity are logged
    * By default, logger connects to _root logger_ which only prints `INFO` and above
<!-- -->
    LOGGER.setLevel(Level.INFO)

    // Get rid of any handlers root has
    LogManager.getLogManager().reset();

    // Everything is passed through
    myLogger.setLevel(Level.ALL);
    // Nothings is passed through
    myLogger.setLevel(Level.OFF);

* Handlers
    - Can have multiple handlers
    - To specify if want to print to console (which _root logger_ does by default)
    - Or it want to save output to a file
<!-- -->
    ConsoleHandler ch = new ConsoleHandler();
    ch.setLevel(Level.SEVERE);
    myLogger.addHandler(ch);
    myLogger.info(e); // exception

    FileHandler fh = new FileHandler("myLogger.log");
    fh.setLevel(Level.FINE);
    myLogger.addHandler(fh);
    fh.setFormatter(myFa); // default: XML

* Put these in a separate method and call it in the `main` class
    - E.g. `.setUp()`
* Logs will be overwritten
* Tips
    - Use fully qualified class name of class as name of Logger
    - Create `toString()` for classes that will appear in logging statements
    - Logging too much may cause performance issues
        - E.g. thread starvation, insufficient storage
    - Be concise and descriptive
        - Should contain both data and description
    - Consider carefully which information to include in pattern
        - E.g. pointless to log date if log rolls every hour since date already included in log file name
    - Log method arguments and return values
        - E.g. When you don't have a debugger because bug manifested itself on a customer environment a few days ago, all you have is logs
    - Watch out for external systems
        - Consider logging every piece of data that comes out from application and gets in
    - Avoid logging exceptions
        - Especially logging exception, wrapping it (i.e. throw another custom exception with `e`) and throw it back

# Documentation Tools

## Markdown

* Lightweight markup language with plain text formatting syntax

| Example | Description |
| --- | --- |
| `![description-of-image](link-to-image)` | Embed images |
| `> Coffee.`| Quote someone (use `>` character before the line) |
| ` ``` ... ``` `| Code fencing to style code without indentation |
| ` ```javascript ``` ` | Style code with syntax highlighting |
| `@jamminity` | Direct comment at someone in GitHub |
| `- [x]` and `- [ ]`| Tasks lists in GitHub (if in first comment of Issue, will see a progress bar in list of issues/ or PRs) |
| `16c999e8c71134401a78d4d46435517b2271d6ac` | SHA references, link to commit on GitHub |
| `#1` | Issue references within repo, linked to that issue |
| `~~this~~` | Strikethrough |

## AsciiDoc

* Similar to Markdown but has more powerful and also complex syntax

https://asciidoctor.org/docs/asciidoc-writers-guide/