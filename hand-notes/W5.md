# CS2103 Notes (Week 5)
## W4 Lecture 6/9

# Resume
* Education
    - If CAP is not high
    - Mention good grades for _relevant_ modules
    - Do tutorships
* Projects
    - _ProjectName_: _description_ (school project)
    - Side-project
    - Contribute to OSS projects (actual production code)
* Competencies
    - Can be tweaked to match the job
    - E.g.

    3 projects, 10 KLoC in total
    used JavaFX, TestFX, Gradle, Travis
    notable PRs: PR1, PRR2

# Requirements

* _Software requirement_
    - Specifies need to be fulfilled by software product
    - Need to be gathered, analysed, specified, managed
* Software project
    - _Brown-field_: develop product to replace/update an existing software product
    - _Green-field_: develop totally new system with no precedent
* Come from stakeholders
    - Parties that are potentially affected by the software project
    - E.g. users, customers, investors, developers, government, stakeholders 
* Identifying requirements
    - Often not easy
    - E.g. Stakeholders not aware of their precise needs
    - E.g. Not know how to communicate requirements correctly
    - E.g. Not willing to spend effort in identifying requirement
* Quality of requirements
    - Well-defined
    - Unambiguous
    - Testable (verifiable)
    - Clear (concise, terse, simple, precise)
    - Correct
    - Understandable
    - Feasible (realistic, possible)
    - Independent
    - Atomic (not divisble any further)
    - Necessary
    - Implementation-free
    - Set of requirements should be
        - Consistent
        - Non-redundant
        - Complete
* Prioritising requirements
    - Based on importance and urgency
    - Keep in mind constraints, schedule, budget, resources, goals etc
    - Group requirements into priority categories
        - Subjective
        - Defined by stakeholders
        - E.g. `Essential`, `Typical`, `Novel`
        - E.g. `High`, `Medium`, `Low`
        - E.g. `Level 0`, `Level 1` etc
    - Can discard requirements if out-of-scope

1. **Functional requirements**
    - Specify what the system should do
    
2. **Non-functional requirements**
    - Specify the constraints under which system is developed and operated
    - Constraints
        - E.g. Need to be backward compatible with earlier versions
    - Data requirements
        - E.g. Size, volatility - how often data change, persistency - saving data permanently
    - Environment requirements
        - E.g. Compatibility with technical environmens
    - Performance requirements
        - E.g. System should respond within 2 seconds
    - Quality requirements
        - E.g. Novice should be able to use
    - E.g. Accessibility, Capacity, Compliance with regulations, Documentation, Disaster recovery, Efficiency, Extensibility, Fault tolerance, Interoperability, Maintainability, Privacy, Portability, Quality, Reliability, Response time, Robustness, Scalability, Security, Stability, Testability etc.
    - Better to know earlier
        - Easier to miss (stakeholders tend to think of functional requirements first)
        - Sometimes critical to success of software


1. Ask
    - Don't assume, clarify
    - Surveys
    - Interviews
    - Focus groups
    - Ask users, customers, investors, developers, government, stakeholders
2. Invent yourself
    - Study existing products 
    - Observe users
    - Brainstorming
3. Record and specifying techniques
    - Prose (just write it down)
    - User stories
        1. Role (_as a product owner_)
        2. Goal/function (_I want to..._)
        3. Benefit (_so that other users can see..._)
    - Feature list
    - Use cases
        - How user interacts with the system
4. Prototypes
    - Low-fidelity
    - High-fidelity
    - Functional
5. Supplementary requirements
    - Mostly non-functional requirements

# Requirement Techniques: **Gathering**

# Requirement Techniques: **Specifying**

# Code Quality

* Learn to follow a standard (objective)
* Comments
    - If you must
    - wrong, tests don't check code, may not be updated
    - good code that are self-explanatory don't really need comments that explain the code 
    - Need comments to explain what the code does, at a higher level
* Avoid magic literals
    - E.g.`SUBSIDY` instead of `250`
* Exploit abstraction
    -SLAP (single level of abstraction per function)
        - Same level of abstraction within a method
    - Use guard conditions
        Reduce nesting of happy path (i.e. main method) of code
* Optimise, if you must
* Messy things get messier
    - Clean up code **frequently**
    - Refactoring
        - Improve program's internal structure
        - In _small_ steps
        - _Without_ modifying its external behaviour

## 1. **Readability**
## 2. **Naming**
## 3. **Unsafe practices**
## 4. **Code comments**

# Refactoring

# Assertions (Java `assert`)

* Used to define assumptions about program state so that runtime can verify them
* Example: _When the execution comes to this point, the variable **v** cannot be null_
* Assertion failure
    - Indicate possible bug in code
    - Code result in program state violates assumption about how code _should_ behave
* When runtime detects an assertion failure
    - Take some drastic action
    - E.g. terminate execution with error message
    - The sooner the execution stops, the safer it is
* Code implementation: 
    - keyword `assert`
<!-- -->
    x = getX();
    // If x is not 0 at this point, assertion will fail with given message
    assert x == 0 : "x should be 0";
    ...

* Can disable assertions without modifying code (default)
<!-- -->
    // Method 1 (run assertions)
    java -enableassertions HelloWorld
    // Method 2
    java -ea HelloWorld
    // Run without verifying assertions (default)
    java -disableassertions HelloWorld

* Enable assertions in Intellij, confirm assertions are being verified
    - Insert `assert false`
* Difference with JUnit assertions
    - Java `assert` similar in purpose
    - But JUnit assertions more powerful, customised for testing
    - Junit assertions not disable by default
    - Where to use
        - JUnit assertions: in test code
        - Java `assert`: in functional code
* Use liberally in code
    - Low impact on performance
    - Worth the additional safety they provide
* Do **not** use assertions to do _work_
    - Because assertions can be disabled
    - Program will stop working when assertions are not enabled
    - If method is performing some work necessary for program, program will not work correctly when assertions disabled
    - Example:
<!-- -->
    ...
    assert writeFile() : "File writing is supposed to return true

* Suitable for verifying assumptions about
    - Internal Invariants
    - Control-Flow Invariants
    - Preconditions
    - Postconditions
    - Class Invariants
* Complementary with exceptions in handling errors in software
    - But serve different purposes
    - Both should be used in code
    - Raising an exception
        - Indicates an unusual condition created by user or environment
        - Exceptions should **not** **terminate** program
        - E.g. user inputs an unacceptable input
        - E.g. file needed for program is missing
    - Assertion failure
        - Indicates programmer made a mistake in code
        - E.g. Null value returned from method that is not supposed to return null under any circumstances

# Java: _streams_

# Continuous Integration/Deployment



